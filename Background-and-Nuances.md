# Background info to Style Guide and Architecture

29/03/2025

*This is a distillation of dozens of raw notes from meetings with tech mentors, generated by Claude.ai in relation to Daniel's style guide and CheckMade's Wiki.*

## Introduction

Software development is not simply about following a set of prescribed rules; it involves navigating complex trade-offs and understanding the historical contexts of various practices. 

The insights in this document don't replace CheckMade's style guide and architecture documentation, but rather complement them by providing deeper context, history and nuance for why certain approaches were chosen and when they might be adapted. By understanding both the rules and their rationale, developers can make more thoughtful decisions when faced with the inevitable gray areas that arise in complex software projects.

This document represent hard-won wisdom from industry veterans with decades of experience across different programming paradigms, platforms, and organizational structures. This document deliberately explores the gray areas and complexities that often don't fit neatly into prescriptive guidelines but nevertheless inform thoughtful software development.

## The Journey of Developer Maturity

### The Shu-Ha-Ri Model of Learning

Software development mastery follows a pattern similar to the Japanese martial arts concept of Shu-Ha-Ri, which describes three stages of learning:

1. **Shu (Obey)**: At this beginning stage, developers follow rules and patterns without question, building a solid foundation of practices. Beginners need clear guidance and consistent patterns to internalize fundamental principles.

2. **Ha (Digress)**: As intermediate developers grow in experience, they begin to question rules and explore alternatives. They understand when established patterns might not be optimal and start to adapt them contextually.

3. **Ri (Separate)**: Advanced developers integrate principles so deeply that they transcend formal structures. They can innovate beyond established patterns, having internalized the underlying principles that guided the original rules.

This model helps explain why CheckMade's style guide is valuable, but also why it must be applied with judgment rather than dogmatically. It also explains why senior developers might seem to "break the rules" in ways that actually demonstrate deeper understanding rather than carelessness.

The professional journey in software engineering isn't about simply accumulating knowledge about languages and frameworks, but about developing judgment about when and how to apply different approaches.

### Understanding the Layers Below

One crucial aspect of developer growth not explicitly stated in our style guide is the importance of understanding the level immediately beneath the one at which you're working. For CheckMade's .NET developers, this means having at least a working understanding of the CLR, memory management patterns, and how garbage collection works.

This knowledge becomes particularly relevant when:
- Diagnosing unexpected performance bottlenecks
- Investigating memory leaks
- Optimizing resource-intensive operations
- Understanding the implications of certain language features

While not every developer needs to write assembly code, everyone benefits from understanding how their high-level code translates to lower-level operations. This prevents the development of "magical thinking" about how code works and enables more effective problem-solving when issues arise.

### Cross-Paradigm Learning

CheckMade's approach emphasizes C# with functional programming principles. However, there's substantial value in exploring radically different programming paradigms. Exposure to languages with fundamentally different approaches—whether purely functional languages like Haskell, logic-based languages like Prolog, or dynamically typed languages like Ruby—expands a developer's conceptual toolkit.

This cross-paradigm experience often leads to unexpected insights when concepts from different programming worlds connect, creating "aha" moments that transform how developers approach problems. Rather than pursuing these alternatives for immediate practical application, the goal is cognitive enrichment and perspective-broadening.

## Testing: Beyond Dogmatic Approaches

### The Testing Spectrum

CheckMade's style guide advocates for thorough testing, but the testing landscape involves nuanced trade-offs that aren't always explicitly discussed. Rather than rigidly adhering to specific testing methodologies, experienced developers understand that testing exists on a spectrum with various approaches offering different benefits:

- **Mockist Testing**: Creates highly isolated tests where dependencies are replaced with test doubles, offering precise control and enabling fine-grained verification of behavior.
  
- **Classical Testing**: Uses real dependencies (or simplified versions) where practical, focusing on verifying end results rather than interactions between components.

Instead of treating these as competing ideologies, successful projects often blend approaches based on what delivers the most value for specific scenarios:

- Use mockist approaches when testing components with complex external dependencies or when specific interaction patterns need verification
- Use classical approaches when behavior can be verified through simple inputs and outputs without excessive setup complexity

The guiding principle should be: "Write tests that teach you something about your code." Tests that can't possibly fail, or that don't convey meaningful information when they pass or fail, provide limited value regardless of their methodological purity.

### Test Brittleness and Evolution

A testing challenge not often addressed in style guides is how tests evolve with the codebase. As systems change, tests must change with them. However, poorly designed tests can become "brittle," requiring extensive updates for even small functional changes.

This represents a tension between two ideals:
1. Complete test coverage that verifies every aspect of the system's behavior
2. Tests that require minimal changes as the system evolves

Finding the right balance means understanding that tests serve multiple purposes:
- Verifying correctness
- Preventing regressions
- Documenting expected behavior
- Enabling safe refactoring

Different testing strategies serve these purposes to varying degrees. The key is maintaining awareness of how test design choices affect maintenance costs as the system evolves.

### The Limited Value of Coverage Tools

CheckMade avoids using test coverage tools, particularly for new, "test-infected" teams (those who write tests as an automatic part of their development process). For such teams, coverage metrics often don't provide meaningful information because:

1. Basic coverage metrics like statement coverage can be misleading. Consider this example:

```csharp
var userId = telegramInputMessage.From?.Id 
              ?? throw new ArgumentNullException(nameof(telegramInputMessage),
                  "From.Id in the input message must not be null");
```

A simple statement coverage tool would report 100% coverage even if tests never triggered the exception path, missing critical edge cases.

2. More sophisticated coverage metrics like path coverage quickly become impractical due to combinatorial explosion in any code of moderate complexity.

3. Targeting arbitrary coverage percentages can lead to low-value tests written purely to improve metrics rather than to verify important behavior.

Instead of focusing on coverage percentages, CheckMade emphasizes thoughtful testing of boundary conditions and error scenarios, particularly those that would be most disruptive if they occurred in production.

## Design by Contract and Error Handling

### The True Meaning of Design by Contract

CheckMade uses Design by Contract (DbC) principles, but there are common misconceptions about how responsibilities are distributed. The proper understanding involves a clear division of responsibilities:

- **Caller's Duty**: Follow the contract by providing valid inputs that meet preconditions
- **Callee's Duty**: Enforce the contract by validating inputs and failing fast when preconditions aren't met

This means validation logic belongs in the method being called, not just in calling code. This approach differs from what some educators mistakenly teach as DbC, where clients must check conditions before calling methods.

It's crucial to distinguish between two fundamentally different types of failure:

1. **Programming Errors**: Contract violations that indicate bugs in the code itself. These should fail fast with clear exceptions.

2. **Expected Runtime Failures**: Errors like network issues or invalid user input that well-written software must handle gracefully.

DbC focuses primarily on the first category, providing mechanisms to detect programming errors early rather than letting them propagate and manifest in confusing ways. The second category is addressed through normal error handling mechanisms like try/catch blocks.

### Avoiding Defensive Programming

A common misconception is equating Design by Contract with Defensive Programming. In reality, they represent almost opposite approaches:

- **Design by Contract**: Fails fast and visibly when contracts are violated, making problems immediately obvious
- **Defensive Programming**: Attempts to "work around" invalid inputs, potentially hiding issues and making debugging much harder

CheckMade explicitly avoids defensive programming except in specific security contexts (like sanitizing user inputs to prevent injection attacks). By failing fast when contracts are violated, the system prevents cascading failures that would be much harder to diagnose.

## Functional Programming in a Mixed Paradigm World

### The Mixed Paradigm Architecture

CheckMade employs a mixed-paradigm approach, using OOP for system organization and FP for implementation details. This isn't simply an ad-hoc blend but follows a specific pattern:

- Domain entities may be stateful, especially at the highest levels where they model real-world concepts
- Implementation details use immutable data structures and pure functions
- Core business logic follows a transformation pattern: reading state, applying pure functions, then persisting the result

This approach maintains conceptual clarity while gaining many benefits of functional programming, particularly around reasoning about code behavior and avoiding side effects.

### Practical Limits of Functional C#

While CheckMade embraces functional programming concepts in C#, it's important to recognize the language's limits. C# wasn't designed as a functional-first language, which creates practical boundaries for how far to push functional techniques.

Advanced functional concepts like currying, while theoretically possible in C#, often introduce more complexity than benefit when implemented without native language support. This is why CheckMade avoids certain functional programming techniques that feel awkward in C#, focusing instead on the functional concepts that integrate naturally:

- Immutable data using records
- LINQ for data transformations
- Higher-order functions where appropriate
- Railway-oriented programming for error handling

Rather than forcing C# to behave like a purely functional language, CheckMade's approach recognizes that the most effective solution comes from working with C#'s strengths while incorporating functional concepts that enhance readability and maintainability.

## Continuous Integration: Historical Context and Nuance

### The Evolution of Code Review

CheckMade's continuous integration workflow includes specific practices around code reviews and branch management, but understanding the historical context adds valuable perspective:

The pull request (PR) workflow now common across the industry originated with GitHub's need to handle submissions from unknown contributors to open source projects. Before this, established teams used different review mechanisms ranging from pair programming to post-commit reviews.

When commercial software teams adopted GitHub's PR model for internal development, they inherited a process designed for different circumstances—open source projects with untrusted contributors rather than cohesive teams. This can introduce unnecessary delays in integration when adopted without consideration.

### Truly Continuous Integration

CheckMade aspires to true continuous integration, where:
- Feature branches are short-lived (hours, not days)
- Integration happens frequently (multiple times per day)
- The main branch remains deployable at all times

Many teams claim to practice CI while maintaining long-lived feature branches and infrequent integrations. This "pseudo-CI" loses many of the benefits of genuine continuous integration:
- Reduced merge conflicts
- Earlier discovery of integration issues
- More frequent feedback on how changes interact with the larger system

These insights have shaped CheckMade's approach to branch management and integration, balancing thorough code review with frequent integration.

## Architecting for Uncertainty

### Risk-First Implementation

When deciding what to implement first in a new project, three common approaches exist:

1. **Infrastructure-First**: Start with architectural foundations and infrastructure (traditional approach from the 1980s-1990s)
2. **Business Value-First**: Deliver whatever provides maximum business value immediately (classic Agile approach)
3. **Risk-First**: Address the most uncertain or risky aspects of the project first

CheckMade often favors the risk-first approach, particularly for innovative projects with significant technical or domain uncertainties. This means tackling the aspects of the system that keep you up at night—whether those are technical risks, knowledge gaps, or critical business assumptions that need validation.

This approach doesn't necessarily conflict with delivering business value, but it recognizes that addressing major risks early often saves significant rework later, even if it means delaying some immediately valuable features.

### The Tension Between YAGNI and Anticipatory Design

CheckMade's architecture attempts to navigate the tension between two seemingly contradictory principles:

1. **YAGNI (You Ain't Gonna Need It)**: Avoid building features or flexibility you don't currently need, as championed by the Pragmatic Programmer
2. **Anticipatory Design**: Design with future changes in mind, as advocated in Design Patterns literature

This apparent contradiction makes more sense when viewed historically. The YAGNI principle arose as a reaction to the prevalent over-engineering of the 1990s, when speculative flexibility often created unnecessary complexity without delivering value.

In practice, experienced architects recognize that both principles have merit in different contexts:
- Use YAGNI when the cost of adding flexibility later is low
- Use anticipatory design when future needs are highly predictable or when retrofitting would be prohibitively expensive

CheckMade handles this tension by designing clear boundaries between components while keeping internal implementations simple, allowing for future extension without speculative complexity.

### Technical Debt as a Tool

While CheckMade generally strives for high code quality, it's important to recognize that technical debt isn't always negative—sometimes it's a conscious investment decision. The key distinction is between:

1. **Unconscious Technical Debt**: Incurred through poor practices or lack of experience, without awareness of the future costs
2. **Strategic Technical Debt**: Deliberately taken on with clear understanding of the trade-offs involved

Strategic technical debt may be appropriate when:
- Product-market fit is still uncertain and rapid experimentation is needed
- Meeting a critical market window requires temporary compromises
- A temporary solution enables learning that will inform a better permanent implementation

The key is making these decisions consciously, rather than drifting into debt through inattention, and having a plan for eventual repayment.

## Composition Over Inheritance: Beyond the Basics

CheckMade favors composition over inheritance, but the reasoning goes deeper than simply following a best practice. The preference stems from fundamental limitations in how inheritance combines subtyping (for polymorphism) and implementation sharing (for code reuse).

These concerns become particularly evident when class hierarchies evolve over time. Consider this example of inheritance:

```csharp
class CountingCollection : MyCollection {
    private int count;
    override void Add(String element) {
        super.Add(element);
        count++;
    }
    
    override void AddAll(String[] elements) {
        super.AddAll(elements);
        count+= elements.Length;
    }
}
```

This approach creates tight coupling between base and derived classes. If the base class implementation of `AddAll` changes to call `Add` internally, the derived class would double-count items when `AddAll` is called.

A composition-based approach resolves this:

```csharp
class CountingCollection {
    private int count;
    private MyCollection collection;
    
    void Add(String element) {
        collection.Add(element);
        count++;
    }
    
    void AddAll(String[] elements) {
        collection.AddAll(elements);
        count+= elements.Length;
    }
}
```

This design decouples the implementations, allowing each class to evolve independently. It also has testing advantages—with inheritance, you must test both the base and derived classes together to verify their interactions, while composition allows each component to be tested in isolation.

The general guideline is to use interfaces for polymorphism and composition for implementation sharing, rather than trying to achieve both through inheritance.

## Database Choices and the Object-Relational Impedance Mismatch

CheckMade's persistence strategy addresses the classic object-relational impedance mismatch—the fundamental disconnect between object-oriented design and relational database structures. While many projects attempt to hide this mismatch behind ORM tools, CheckMade takes a more direct approach:

1. **Flattened Schema**: Using a relatively flat database schema with serialized JSONB fields for details, reducing the need for complex relational mapping
2. **Event Sourcing for Operations**: Storing operations as immutable events that can be replayed to derive current state
3. **Clear Boundaries Between Persistence Layers**: Using repositories to clearly separate domain logic from storage concerns

This approach recognizes that the impedance mismatch becomes most problematic when domain models and database schemas are developed independently. By starting with the domain model and deriving the database structure from it, many common pitfalls are avoided.

The persistence strategy also acknowledges different data access patterns:
- Operational queries typically focus on specific entities or small groups of related entities
- Analytical queries often span large datasets and look for aggregate patterns

Rather than trying to optimize a single database structure for both patterns, CheckMade's approach allows for specialized optimizations where needed.

## Integration Testing: Same Language, Real Dependencies

CheckMade takes a specific position on integration testing that differs from common practices:

1. **Same Language Across Test Types**: Using C# for both unit and integration tests, rather than switching to scripting languages like Python for integration testing
2. **Real Dependencies Where Practical**: Using actual (rather than in-memory) databases for integration tests to ensure realistic behavior

This approach rejects the notion that integration tests should use simpler technologies because they're "just scripts." In practice, integration test suites evolve into complex systems that benefit from the same engineering rigor as production code:

- Strong typing catches many errors before tests run
- Consistent language across all tests reduces context switching
- Shared utilities and test helpers work across test types
- IDE support remains consistent across the codebase

While this may initially seem like additional overhead, it prevents the long-term maintenance burden that comes from maintaining parallel test infrastructures in different languages.

## Performance Considerations: When to Optimize

CheckMade follows a nuanced approach to performance optimization that goes beyond simple "premature optimization is the root of all evil" maxims. Two key aspects of performance are considered separately:

1. **Initialization/Cold-Start Performance**: How quickly the system can start from scratch
2. **Operational Performance**: How efficiently the system handles ongoing operations

These different performance characteristics often involve different optimization strategies and trade-offs. For serverless architectures like CheckMade's Azure Functions, cold-start performance can be particularly important due to the potential for functions to be unloaded between invocations.

Rather than focusing on micro-optimizations like using smaller numeric types (byte vs. int), attention is directed to architectural decisions with more significant performance impacts:

Data structure choices, caching strategies, and query optimization generally yield more substantial benefits than low-level optimizations. However, for large collections (millions of elements), element size can become significant—the context matters greatly.

## Documentation: Purpose-Driven Approach

CheckMade distinguishes between different types of documentation based on their intended audience and longevity:

1. **Decision Support Documents**: Created to facilitate specific decisions and may be archived after the decision is made
2. **Architectural Documentation**: Long-lived documentation describing system structure and rationale
3. **Self-Documenting Code**: Clear naming and structure that reduces the need for inline comments
4. **Code Comments**: Reserved for explaining non-obvious decisions or external constraints

Documentation is created with a clear understanding of how long it's expected to remain relevant and who needs to use it. This prevents both under-documentation (where crucial context is lost) and over-documentation (where maintaining documentation becomes burdensome without providing value).

Comments within code are used sparingly, focusing on the "why" rather than the "what" when the rationale for a decision isn't obvious from the code itself.

## Conclusion: The Art of Balance

Software development at its highest level involves balancing competing forces:
- Flexibility vs. simplicity
- Speed of delivery vs. technical excellence
- Abstract principles vs. pragmatic realities

CheckMade's approach acknowledges these tensions without pretending they can be resolved through simple rules. Instead, it cultivates judgment about when to apply different practices based on context-specific factors.
